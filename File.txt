Теория: Файлы

Часто бывает, что программе необходимо обрабатывать и хранить данные, расположенные снаружи: параметры конфигурации, некоторый набор данных для обработки, журналы выполнения и так далее. Самый простой способ хранения данных - использовать файлы, которые поддерживаются всеми современными операционными системами. Вы можете рассматривать файл как совокупность данных, которые хранятся на диске или другом устройстве и которыми можно манипулировать как единым целым, если обращаться к нему по имени. Файлы могут быть организованы в каталоги, которые действуют как папки для других файлов и каталогов.

На этом уроке мы узнаем, как работать с файлами непосредственно из Java-программы.

Класс File
Существует класс называется Fileв java.ioпакете. Объект этого класса представляет существующий или несуществующий файл или каталог. Класс может использоваться для управления файлами и каталогами: создание, удаление, доступ к свойствам и многое другое.

Самый простой способ создать объект - передать путь к его конструктору. Допустимый формат строки зависит от операционной системы:

Windows использует обратную косую черту для путей ( '\'),
Linux, OS X, Android и другие UNIX-подобные системы используют косую черту ( '/').
Вы должны иметь в виду эту разницу при работе с файлами.

Если ваша операционная система Windows, не забудьте использовать escape-символ '\'.

Давайте создадим два объекта Fileкласса для разных платформ.

File fileOnUnix = new File("/home/username/Documents");    // a directory on a UNIX-like system
File fileOnWin = new File("D:\\Courses\\java-course.pdf"); // a file on Windows
Код будет работать, даже если файл или каталог на самом деле не существует в вашей файловой системе. Он не создает новый файл или каталог. Он просто представляет «виртуальный» файл или каталог, который уже существует или может быть создан в будущем.

Чтобы отобразить символ для разделения пути к файлу в вашем случае, вы можете напечатать следующее:

System.out.println(File.separator); // '/' - for Linux
Объекты Fileкласса неизменны; то есть, после создания абстрактный путь, представленный объектом, никогда не изменится.

Абсолютный и относительный путь
Вы уже видели примеры файлов, описываемых абсолютным путем . Проще говоря, путь является абсолютным, если он начинается с корневого элемента файловой системы. Он содержит полную информацию о местонахождении файла, включая тип операционной системы.

Считается плохой практикой находить файл, используя его абсолютный путь внутри ваших программ, поскольку вы потеряете возможность повторного использования вашей программы на разных платформах. Другая проблема заключается в том, что вы не можете передать файл по указанному каталогу, вам придется изменить код, который обращается к нему.
Относительный путь это путь , который не включает в себя корневой элемент файловой системы. Это всегда начинается с вашего рабочего каталога . Этот каталог представлен .(точка). Относительный путь не является полным и должен быть объединен с текущим путем к каталогу для достижения запрошенного файла.

Вот пример с файлом в каталоге images, который находится в вашем рабочем каталоге:

File fileOnUnix = new File("./images/picture.jpg");
File fileOnWin = new File("./images/picture.jpg");
Как видите, оба пути выглядят одинаково, что обеспечивает независимость от платформы. Интересно, что символ точки можно пропустить, поэтому путь images/picture.jpgтоже правильный.

Чтобы создавать независимые от платформы программы, принято использовать относительный путь, когда это возможно. Вы также можете перенести весь рабочий каталог, который содержится images/picture.jpgбез каких-либо изменений кода.
Чтобы получить доступ к родительскому каталогу другого каталога, просто напишите ..(двойная точка). Итак, ../picture.jpgэто файл, размещенный в родительском каталоге рабочего каталога. Относительный путь images\..\picture.jpgозначает подкаталог imagesв рабочем каталоге, а затем файл picture.jpg. Это в основном то же самое, что и просто picture.jpg.

Основные методы
Экземпляр File  будет иметь список методов. Взгляните на некоторые из них:

String getPath() возвращает путь строки к этому файлу или каталогу;
String getName() возвращает имя этого файла или каталога (только фамилия пути)
boolean isDirectory()возвращает, trueесли это каталог и существует, в противном случае false;
boolean isFile()возвращает trueэто файл (не каталог) и существует, в противном случае false;
boolean exists()возвращает, trueесли этот файл или каталог действительно существует в вашей файловой системе, в противном случае false;
String getParent() возвращает путь строки к родительскому каталогу, в котором находится этот файл или каталог.
Список не полный, но пока мы сосредоточимся на них. Для других методов, смотрите здесь .

Давайте создадим экземпляр существующего файла и распечатаем некоторую информацию о нем.

File file = new File("/home/username/Documents/javacourse.pdf");
 
System.out.println("File name: " + file.getName());
System.out.println("File path: " + file.getPath());
System.out.println("Is file: " + file.isFile());
System.out.println("Is directory: " + file.isDirectory());
System.out.println("Exists: " + file.exists());
System.out.println("Parent path:" + file.getParent());
Как мы ожидаем, код печатает следующее:

File name: javacourse.pdf
File path: /home/username/Documents/javacourse.pdf
Is file: true
Is directory: false
Exists: true
Parent path: /home/username/Documents
Предположим, теперь у нас есть экземпляр, который представляет несуществующий файл и печатает информацию о нем:

File name: javacourse1.pdf
File path: /home/art/Documents/javacourse1.pdf
Is file: false
Is directory: false
Exists: false
Parent path:/home/art/Documents
Файл не существует, и приложение не знает его тип.

Существует также группа методов canRead(), canWrite(), canExecute()чтобы проверить , является ли приложение может прочитать / изменить / выполнить файл , обозначенный путь. Рекомендуется использовать эти методы, в противном случае вы можете столкнуться с ошибками доступа к файлу, когда у вашего пользователя недостаточно прав для выполнения операции с файлом.

Мы считаем, что этот Fileкласс предоставляет очень понятный API для обработки файлов и каталогов на разных платформах.