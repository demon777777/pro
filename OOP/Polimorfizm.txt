Виды полиморфизма
В общем, полиморфизм означает, что что-то (объект или другая сущность) имеет много форм.

Java предоставляет два типа полиморфизма: статический (во время компиляции) и динамический (во время исполнения) полиморфизм. Первый достигается перегрузкой метода , второй основан на наследовании и переопределении метода .

Более теоретический подход подразделяет полиморфизм на несколько принципиально разных типов:

Специальный полиморфизм относится к полиморфным функциям, которые могут применяться к аргументам разных типов, но ведут себя по-разному в зависимости от типа аргумента, к которому они применяются. Java поддерживает это как перегрузку метода .
Полиморфизм подтипа (также известный как подтип) - это возможность использовать экземпляр подкласса, когда разрешен экземпляр базового класса.
Параметрический полиморфизм  - это когда код написан без упоминания какого-либо конкретного типа и, таким образом, может прозрачно использоваться с любым количеством новых типов. Java поддерживает его как обобщение или обобщенное программирование .
В этой теме мы рассмотрим только полиморфизм подтипа (времени выполнения), который широко используется в объектно-ориентированном программировании.

Полиморфное поведение во время выполнения
Напоминание:  переопределение метода  - это когда подкласс переопределяет метод суперкласса с тем же именем.

Полиморфизм времени исполнения опирается на два принципа:

ссылочная переменная суперкласса может ссылаться на любой объект подтипа;
метод суперкласса может быть переопределен в подклассе.
Полиморфизм времени выполнения работает, когда переопределенный метод вызывается через ссылочную переменную суперкласса. Во время выполнения Java определяет, какая версия метода (суперкласс / подклассы) должна выполняться, основываясь на типе объекта, на который ссылаются, а не на типе ссылки. Он использует механизм, известный как диспетчеризация динамических методов .

Пример. Здесь вы можете увидеть иерархию классов. Суперкласс MythicalAnimalимеет два подкласса: Chimeraи Dragon. Базовый класс имеет метод hello. Оба подкласса переопределяют этот метод.

class MythicalAnimal {    
 
    public void hello() {
        System.out.println("Hello, I'm an unknown animal");
    }
}
 
class Chimera extends MythicalAnimal {
 
    public void hello() {
        System.out.println("Hello! Hello!");
    }
}
 
class Dragon extends MythicalAnimal {
 
    public void hello() {
        System.out.println("Rrrr...");
    }
}
Мы можем создать ссылку на класс MythicalAnimalи присвоить ее объекту подкласса:

MythicalAnimal chimera = new Chimera();
MythicalAnimal dragon = new Dragon();
MythicalAnimal animal = new MythicalAnimal();
Мы также можем вызывать переопределенные методы через ссылки на базовый класс:

animal.hello(); // Hello, i'm an unknown animal
chimera.hello(); // Hello! Hello!
dragon.hello(); // Rrrr...
Таким образом, результат вызова метода зависит от фактического типа экземпляра, а не от ссылочного типа. Это полиморфная особенность в Java. JVM вызывает соответствующий метод для объекта, на который ссылается каждая переменная.

Полиморфизм подтипов позволяет классу определять методы, которые будут общими для всех его подклассов, в то же время позволяя подклассам определять конкретные реализации некоторых или всех этих методов. Это очень полезно для объектно-ориентированного проектирования, особенно вместе с абстрактными методами и интерфейсами, о которых вы узнаете в других темах.

Полиморфизм в иерархии классов
То же самое работает с методами, которые используются только внутри иерархии и недоступны извне.

Пример. Существует иерархия файлов. Родительский класс Fileпредставляет собой описание одного файла в файловой системе. У него есть подкласс по имени ImageFile. Переопределяет метод getFileInfoродительского класса.

class File {
 
    protected String fullName;
 
    // constructor with a single parameter
 
    // getters and setters
 
    public void printFileInfo() {
        String info = this.getFileInfo(); // here is polymorphic behaviour!!!
        System.out.println(info);
    }
 
    protected String getFileInfo() {
        return "File: " + fullName;
    }
}
 
class ImageFile extends File {
 
    protected int width;
    protected int height;
    protected byte[] content;
 
    // constructor
 
    // getters and setters
 
    @Override
    protected String getFileInfo() {
        return String.format("Image: %s, width: %d, height: %d", fullName, height, width); 
    }
}
Родительский класс имеет открытый метод printFileInfoи защищенный метод getFileInfo. Второй метод переопределяется в подклассе, но подкласс не переопределяет первый метод.

Давайте создадим экземпляр класса ImageFileи назначим его переменной File.

File img = new ImageFile("/path/to/file/img.png", 640, 480, someBytes); // assigning an object
Теперь, когда мы вызываем метод printFileInfo, он вызывает переопределенную версию метода getFileInfo.

img.printFileInfo(); // It prints "Image: /path/to/file/img.png, width: 480, height: 640"
Таким образом, полиморфизм во время выполнения позволяет вам вызывать переопределенный метод подкласса, имеющего ссылку на базовый класс.

