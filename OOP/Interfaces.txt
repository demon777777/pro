Объявление интерфейсов
---------------------------------------------------------
Интерфейс представляет собой особый вид класса , который является еще более абстрактным , чем абстрактный класс. Часто (но не всегда) он содержит только абстрактные методы, которые вы можете реализовать в подклассах.

Как и абстрактный класс, интерфейс не может быть создан. Чтобы объявить интерфейс, вы должны написать ключевое слово interfaceвместо classимени интерфейса:

public interface Interface { }
Интерфейс может содержать:

публичные константы;
абстрактные методы без реализации (ключевое слово abstractздесь не требуется);
методы по умолчанию с реализацией начиная с Java 8 (ключевое слово defaultобязательно);
статические методы с реализацией (ключевое слово staticобязательно).
Статические и стандартные методы должны иметь реализацию в интерфейсе!
Интерфейс не может содержать поля (только константы ), конструкторы и непубличные абстрактные методы. Начиная с Java 9 частные методы по умолчанию также допускаются.

Давайте объявим интерфейс, содержащий все возможные члены:

interface Interface {
        
    int INT_CONSTANT = 0; // it's a constant, the same as public static final INT_FIELD = 0
        
    void instanceMethod1();
        
    void instanceMethod2();
        
    static void staticMethod() {
        System.out.println("Interface: static method");
    }
        
    default void defaultMethod() {
        System.out.println("Interface: default method. It can be overridden");
    }
}
Давайте внимательнее посмотрим на этот интерфейс. Переменная INT_CONSTANTздесь не поле, это статическая конечная константа. Два метода instanceMethod1()и instanceMethod2()являются абстрактными методами. Это staticMethod()обычный статический метод. Метод по умолчанию defaultMethod()имеет реализацию, но он может быть переопределен в подклассах.

Маркерные интерфейсы
В некоторых ситуациях интерфейс не может иметь членов вообще. Такие интерфейсы называются маркерными или теговыми интерфейсами . Например, известный интерфейс Serializable- это маркерный интерфейс:

public interface Serializable{ 
}
Другие примеры маркеров интерфейсов Cloneable, Remoteи т.д. Они используются для предоставления важной информации для виртуальной машины Java.

Реализация интерфейсов
Класс (даже абстрактный) может наследовать интерфейс, используя ключевое слово implements. Если класс не является абстрактным, мы должны предоставить реализации для всех абстрактных методов интерфейса.

Давайте реализуем интерфейс, который мы рассмотрели ранее:

class Class implements Interface {
 
    @Override
    public void instanceMethod1() {
        System.out.println("Class: instance method1");
    }
 
    @Override
    public void instanceMethod2() {
        System.out.println("Class: instance method2");
    }
}
Теперь мы можем создать экземпляр класса и вызвать его методы:

Interface instance = new Class();
 
instance.instanceMethod1(); // it prints "Class: instance method1"
instance.instanceMethod2(); // it prints "Class: instance method2"
instance.defaultMethod();   // it prints "Interface: default method. It can be overridden"
Реализация и расширение нескольких интерфейсов
Одно из основных различий между абстрактными классами и интерфейсами заключается в том, что интерфейсы поддерживают множественное наследование .

Класс может реализовывать несколько интерфейсов:

interface A { }
    
interface B { }
    
interface C { }
    
class D implements A, B, C { }
Интерфейс может расширять один или несколько других интерфейсов, используя ключевое слово extends:

interface A { }
 
interface B { }
 
interface C { }
 
interface E extends A, B, C { }
Класс также может расширять другой класс и реализовывать несколько интерфейсов:

abstract class A { }
    
interface B { }
    
interface C { }
    
class D extends A implements B, C { }
Все приведенные выше примеры не представляют никаких проблем.

Многократное наследование интерфейсов часто используется в стандартной библиотеке классов Java. Например, класс String реализует три интерфейса одновременно:

public final class String 
    implements java.io.Serializable, Comparable<String>, CharSequence {
// ...
}