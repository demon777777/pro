Теория: Инкапсуляция создания объекта
===========================================

Создание объектов на фабриках

Иногда у нас есть иерархия классов с одним базовым классом (или интерфейсом) и несколькими подклассами, и нам нужно создать новый объект подкласса в зависимости от его типа. Вместо написания  newоператора в клиентском коде, где мы будем использовать объекты, удобно инкапсулировать код для создания объектов в отдельном месте и вызывать его из клиентского кода. Эти места известны как фабрики,  которые производят экземпляры классов, относящихся к одной и той же иерархии. Они позволяют нам упростить клиентский код и защитить его от изменений при добавлении новых классов в иерархию.

Таким образом, фабрика - это способ создания объектов, когда одна часть программы (класс или метод) создает объекты, а другая обрабатывает их.

Существует несколько видов фабрик: статическая фабрика , простая фабрика , фабричная методика и абстрактная фабрика . В этой теме мы будем изучать только первые два; их часто называют  идиомами, а не шаблонами проектирования. Но последние два - это реальные шаблоны проектирования, основанные на тех же принципах, что и эти идиомы.

Статическая фабричная идиома
В качестве примера рассмотрим следующую иерархию компьютеров:

class Computer {
    
    private long ram;
    private long cpu;
    
    // getters and setters
}
 
class PC extends Computer { 
    
    // additional members
}
 
class Laptop extends Computer { 
    
    // additional members
}
 

Статическая фабрика - это самая простая фабрика, которую мы можем написать. У него есть один статический метод, который создает объекты иерархии. Метод принимает требуемый тип в качестве аргумента строки или перечисления и возвращает соответствующий экземпляр подкласса через базовый класс.

Для создания новых компьютеров мы вызываем статическую фабрику, передавая требуемый тип:

class ComputerStaticFactory {
    
    public static Computer newInstance(String type) {
        if (type.equals("Computer")) {
            return new Computer();
        } else if (type.equals("PC")) {
            return new PC();
        } else if (type.equals("Laptop")) {
            return new Laptop();
        }
        return null; // if not a suitable type
    }
}
 

В зависимости от переданного типа, подходящая ветка будет работать. Мы также можем написать то же самое, используя switch.

Следующий клиентский код создает два компьютера: ноутбук и ПК:

public class FactoryClient {
    
    public static void main(String args[]) {
        
        Computer pc = ComputerStaticFactory.newInstance("PC");
        System.out.println(pc instanceof PC); // prints "true"
       
        Computer laptop = ComputerStaticFactory.newInstance("Laptop");
        System.out.println(laptop instanceof Laptop); // prints "true"
    }
}
Нетрудно объявить новый класс, который расширяет Computerи модифицирует фабрику для создания экземпляров нового класса.

Есть несколько возможных особенностей реализации:

метод newInstanceиз ComputerStaticFactoryпринимает тип перечисления , чтобы ограничить возможные значения;
метод newInstanceвыдает исключение, если вместо возврата передается неподходящий тип null;
переместите метод newInstanceнепосредственно в основание иерархии:  Computerкласс;
фабрика может иметь несколько методов, которые создают экземпляры разных классов или экземпляр класса по умолчанию.
Простая фабричная идиома
Простые фабричные идиомы отличаются от статической фабрики, потому что метод создания объектов нестатичен.

class ComputerFactory {
    
    // it may contain some fields
    
    public Computer newInstance(String type) {
        if (type.equals("Computer")) {
            return new Computer();
        } else if (type.equals("PC")) {
            return new PC();
        } else if (type.equals("Laptop")) {
            return new Laptop();
        }
        return null;
    }
}
 

В клиентском коде мы должны создать экземпляр фабрики и затем вызвать newInstance, как показано ниже:

 

ComputerFactory factory = new ComputerFactory();
Computer pc = factory.newInstance("PC");
 

Простая фабричная идиома имеет те же особенности, что и статическая фабричная. Но, в отличие от статической фабрики, можно создать несколько фабрик с различными параметрами, чтобы управлять созданием экземпляров. Вы также можете создать подкласс фабрики и переопределить ее нестатический метод, который используется для создания других фабрик.

Вывод
Мы рассмотрели две фабричные идиомы в действии: статическая фабрика и простая фабрика . Они на самом деле не являются шаблонами проектирования, но, тем не менее, оба полезны на практике; другие заводы в значительной степени опираются на те же принципы.

Согласно принципам, мы инкапсулируем код для создания объектов иерархии в специальном месте (фабрике). У фабрики есть метод, который принимает тип требуемого объекта в качестве параметра и возвращает подходящий экземпляр клиентскому коду. Он защищает код клиента от изменения иерархии классов и упрощает понимание и поддержку.

Также следует помнить, что на фабрике может быть несколько клиентов, которым необходимо создавать объекты. Им не нужно дублировать тот же код, который вызывает newоператор для создания экземпляра.